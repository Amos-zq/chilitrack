#ifndef _CHILITRACK_H
#define _CHILITRACK_H

#include <opencv2/opencv.hpp>
#include <vector>

#include "stats.h" // Stats structure definition

namespace chilitrack {

class Template
{

public:
    // Nb of features used for tracking the template
    static const int NB_FEATURES = 50;

    /**
     *
     * Size is the *physical size*, in mm, of the template image
     */
    Template(cv::Mat tpl, 
             cv::Size size, 
             cv::Ptr<cv::Feature2D> detector = cv::Ptr<cv::Feature2D>());

    cv::Mat image() const {return _tpl;}
    cv::Mat debug() const {return _tpl_debug;}

    std::vector<cv::KeyPoint> kpts;
    cv::Mat desc;
    std::vector<cv::Point2f> tracking_kpts;

    std::vector<cv::Point3f> tpl_points;
    cv::Rect bb;

    bool tracked;

protected:
    cv::Mat _tpl;
    cv::Mat _tpl_debug;
};

class Tracker
{
public:
    Tracker(cv::Ptr<cv::Feature2D> _detector = cv::Ptr<cv::Feature2D>(),
            cv::Ptr<cv::DescriptorMatcher> _matcher = cv::Ptr<cv::DescriptorMatcher>());

    /** Main tracking method: takes an image and returns all the 4x4 transformations     matrices for the templates found in the image.
     */
    std::map<std::string, cv::Matx44d> estimate(
                                const cv::Mat frame, 
                                cv::Ptr<Stats> stats = cv::Ptr<Stats>());


    void add_template(const std::string& id, cv::Ptr<Template> tpl) {
        _templates[id] = tpl;
    }

    cv::Ptr<cv::Feature2D> getDetector() {return detector;}

    /**
      For accurate results, chilitrack can be provided the calibration data of
      the camera detecting the chilitags.  See
      https://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html
      for background on this topic.

      Note that this method can be called as often as needed with a new calibration
      configuration (for instance if the user switched to another camera).

      \param newCameraMatrix the 3x3 matrix of the camera intrinsics (see
        https://en.wikipedia.org/wiki/Camera_resectioning#Intrinsic_parameters).
      \param newDistCoeffs a vector containing the distortion coefficients.
    */
    void setCalibration(cv::InputArray newCameraMatrix,
            cv::InputArray newDistCoeffs);

    /**
      For accurate results, Chilitags3D can be provided the calibration data of
      the camera detecting the chilitags.  See
      http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html
      for background on this topic.

      Note that this method can be called as often as needed with a new calibration
      configuration (for instance if the user switched to another camera).

      This method is similar to setCalibration, but reads the camera calibration
      information directly from a file, as generated by OpenCV's 'calibration'
      sample.

      \param filename the path to a file containing the calibration data
      */
    void readCalibration(const std::string &filename);

    cv::Mat _debug;

protected:
    void match(const cv::Mat frame, cv::Ptr<Template> tpl, cv::Ptr<Stats> stats);
    cv::Matx44d track(const cv::Mat frame, cv::Ptr<Template> tpl, cv::Ptr<Stats> stats);

    cv::Ptr<cv::Feature2D> detector;
    cv::Ptr<cv::DescriptorMatcher> matcher;

    std::vector<cv::Point3f> tpl_points;
    std::vector<cv::Point2f> features;

    // when tracking, store the previous frame for optical flow computation
    cv::Mat prev_frame;

    cv::Size frameSize;
    cv::Mat cameraMatrix;
    cv::Mat distCoeffs;

    std::map<std::string, cv::Ptr<Template>> _templates;

private:
    cv::Matx44d computeTransformation(cv::Ptr<Template> tpl) const;

    void pruneFeatures(std::vector<cv::Point2f>& features, 
                       std::vector<cv::Point3f>& tpl_points );
    cv::Point2f _centroid;
    double _variance;

    // Rotation & translation vectors, computed by cv::solvePnP
    cv::Mat_<double> rotation, translation;

};

};

#endif // _CHILITRACK_H
